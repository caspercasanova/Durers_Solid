extends Node
class_name Damage_Source


# _could make this entire file a flat entity ....





# REMEMBER DAMAGE_SOURCE is super generic and should remain so, mold things around it 
# https://www.youtube.com/watch?v=oIrvZDDWxhU

# Inflictor is the weapon or rocket (or player) that is dealing the damage.
# Weapon is the weapon that did the attack.
# For hitscan weapons, it'll be the same as the inflictor. For projectile weapons, the projectile 
# is the inflictor, and this contains the weapon that created the projectile.
# Attacker is the character who originated the attack (like a player or an AI).
var _inflictor : Object = null : set = setInflictor, get = getInflictor
var _weapon : Object = null: set = setWeapon, get = getWeapon
# damage_source_stat might be a better option to cover here?
var _attacker : Object = null: set = setAttacker, get = getAttacker
var _damage : float = 0.0: set = setDamage, get = getDamage
var _baseDamage : float = 0.0: set= setBaseDamage, get = getBaseDamage
var _maxDamage : float = 0.0: set= setMaxDamage,get = getMaxDamage
var _damageBonus : float = 0.0: set= setDamageBonus, get=  getDamageBonus
var _damageForce : Vector3 = Vector3(0, 0, 0): set= setDamageForce, get = getDamageForce
var _damagePosition : Vector3 = Vector3(0, 0, 0): set= setDamagePosition, get = getDamagePosition
var _damageType : Damage_Types = 0: set= setDamageType,get = getDamageType
var _damageCustom : int = 0: set= setDamageCustom,get= getDamageCustom
# interesting?
var _damageStats : int = 0: set= setDamageStats, get=getDamageStats
# probably dont need this, ammos themselves update the damage? but maybe needed for the size of the object?
var _ammoType : int = 0: set= setAmmoType, get=getAmmoType
var _playerPenetrationCount : int = 0: set= setPlayerPenetrationCount, get =getPlayerPenetrationCount
var _damagedOtherPlayers : int = 0: set= setDamagedOtherPlayers, get =getDamagedOtherPlayers
var _reportedPosition : Vector3 = Vector3(0, 0, 0): set= setReportedPosition, get = getReportedPosition
var _forceFriendlyFire : bool = false: set= setForceFriendlyFire, get=getForceFriendlyFire
var _phys_pushscale = 1
var _mass: int = 0;
var size: int = 0;


func _init() -> void:
	return



static func impulse_scale(target_mass: float, desired_speed: float) -> float:
	return target_mass * desired_speed


static func damage_force(size: Vector3, damage: float = 1) -> float:
	var force = damage * (32 * 32 * 72.0) / (size.x * size.y * size.z) * 5
	
	if force > 1000.0:
		force = 1000.0

	return force


#print("Inflictor: ", p_inflictor)
#print("Attacker: ", p_attacker)
#print("Weapon: ", p_weapon)
#print("Damage Force: ", damage_force)
#print("Damage Position: ", damage_position)
#print("Damage Amount: ", fl_damage)
#print("Damage Type: ", bits_damage_type)
#print("Kill Type: ", i_kill_type)
#print("Reported Position: ", reported_position)


# make easier for idk? 
func fromBullet(bullet_type: Bullet_Types, vec_bullet_dir: Vector3, vec_force_origin: Vector3, fl_scale: float = 1.0) -> Damage_Source:
	return Damage_Source.new()

static func fromMelee() -> Damage_Source:
	return Damage_Source.new()

static func fromProjectileWeapon() -> Damage_Source:
	return Damage_Source.new()

static func fromRocket() -> Damage_Source:
	return Damage_Source.new()

static func fromRayCastWeapon() -> Damage_Source:
	return Damage_Source.new()

static func fromPhysicsWeapon() -> Damage_Source:
	return Damage_Source.new()

static func fromSpell() -> Damage_Source:
	return Damage_Source.new()


# PLAYER / NPC SHIT
func take_damage(damage_source: Damage_Source):
	return

func react_to_damage(damage_source: Damage_Source):
	return
	
	

# https://github.com/ValveSoftware/source-sdk-2013/blob/0d8dceea4310fde5706b3ce1c70609d72a38efdf/sp/src/game/shared/basecombatweapon_shared.h#L283
# https://github.com/ValveSoftware/source-sdk-2013/blob/0d8dceea4310fde5706b3ce1c70609d72a38efdf/sp/src/game/server/physics_impact_damage.h#L54
# https://github.com/ValveSoftware/source-sdk-2013/blob/0d8dceea4310fde5706b3ce1c70609d72a38efdf/sp/src/game/shared/takedamageinfo.h#L24
# https://www.youtube.com/watch?v=oIrvZDDWxhU
enum Damage_Types {
	GENERIC = 0,
	CRUSH,  #	crushed by falling or moving object.
			#	NOTE: It's assumed crush damage is occurring as a result of physics collision,
			#	so no extra physics force is generated by crush damage.
			#	DON'T use DMG_CRUSH when damaging entities unless it's the result of a physics collision.
			#	You probably want DMG_CLUB instead.
	BULLET, # shot
	SLASH,  # slash, clawed, stabbed
	BURN,	# heat burned
	VEHICLE, # hit by vehicle
	FALL,	# fell to floor
	BLAST,  # explosive blast
	CLUB,   # crowbar headbut punch
	SHOCK,  # electric shock
	SONIC, 	# sound pulse shockwave
	ENERGYBEAM, # high energy
	PREVENT_PHYSICS_FORCE, # prevent physics force
	NEVERGIB, # 
	ALWAYSGIB, # 
	DROWN, # drown - heals over time like drowning damage
	PARALYZE, # slows affected down
	NERVEGAS, # nerve toxins
	POISON,   # blood poisoning - heals over time like drowning damage
	RADIATION, # radiation exposure
	DROWNRECOVER, # drowning recovery 
	ACID, # toxic chemicals or acid burns
	SLOWBURN, # in an oven
	REMOVE_NO_RAGDOLL, # with this bit OR'd in, no ragdoll will be created, and the target will be quietly removed. use this to kill an entity that you've already got a server-side ragdoll for
	PHYSGUN, # Hit by manipulator. Usually doesn't do any damage.
	PLASMA, # Shot by Cremator
	DISSOLVE, # dissolving 
	BLAST_SURFACE, # A blast on the surface of water that cannot harm things underwater
	DIRECT,
	BUCKSHOT, # not quite a bullet. Little, rounder, different
};


class Bullet:
	var bullet_type: Bullet_Types = Bullet_Types.STANDARD

class Rocket:
	var rocket_type: Rocket_Types = Rocket_Types.STANDARD

class Explosive_Device:
	var explosive_device: Explosive_Devices = Explosive_Devices.SMOKE_GRENADE

class Projectile_Weapon:
	var projectile_weapon: Projectile_Weapons = Projectile_Weapons.SEMI_AUTO_SECONDARY
	
class Physics_Weapon:
	var physics_weapon: Physics_Weapons = Physics_Weapons.FLAME_THROWER

class Ray_Cast_Weapon:
	var ray_cast_weapon: Ray_Cast_Weapons = Ray_Cast_Weapons.CHAOS_GUN

class Melee_Weapon:
	var melee_weapon: Melee_Weapons = Melee_Weapons.FIST




# Constants for AmmoTracer_t
enum TracerTypes {
	TRACER_NONE,
	TRACER_LINE,
	TRACER_RAIL,
	TRACER_BEAM,
	TRACER_LINE_AND_WHIZ
}




enum Equipment {
	RADIO,
	GRAPPLE_GUN,
	PARACHUTE, 
	MEDIC,
	AMMO_POUCH, 
	SPOTTER,
}

enum Melee_Weapons {
	FIST, 
	BITE,
	BOWIE_KNIFE,
	TWO_BY_FOUR,
	WEAPON, # Used for every weapon
}

# Need to investigat this
# just different color ray casts for prototyping 
enum Ray_Cast_Weapons {
	LAZER_RIFLE,
	CHAOS_GUN,
	ZOMBIE_GUN,
	DEATH_RAY,
}


# Can have cooldown and charge up weapons too
enum Physics_Weapons {
	FLAME_THROWER,
	ELECTRO_CURVE_GUN,
	GRAVITY_GUN,
	FREEZE_GUN,
}

enum Projectile_Weapons {
	SEMI_AUTO_SECONDARY,
	AUTO_SECONDARY,
	AR,
	SMG,
	LMG,
	MMG,
	HMG,
	SHOTGUN,
	SNIPER,
	BAZOOKA,
	MINIGUN,  # Probably not super heavy machine gun
	CANNON,
	MORTAR,
}


#grenades are the same as dumb bombs kinda
enum Explosive_Devices {
	SMOKE_GRENADE,
	FRAGMENT_GRENADE,
	PUSH_PULL_GRENADE,
	DUMB_BOMB,
	C4,
	TNT,
	NAPALM_GRENADE,
	GAS_GRENADE,
}


enum Rocket_Types {
	STANDARD,
	ROCKET,
	HOMING_MISSILE,
	SWARM_ROCKET,
}


# use for more of the gun resources 
# BRO TRACERS THAT SPAWN ITEMS???? SHEESH
# https://x.com/garrynewman/status/1710361924033016060?s=20
# need to implement this shit it would be sickkkkkkkkk
enum Bullet_Types {
	STANDARD, 
	ARMOR_PIERCE, #red
	EXPLOSIVE, #green
	ELECTRO, #electricblue
	HOMING, #yellow
	FREEZING, #cyan
	CHAOS, #black
}


# return ammo sizes for all projectile weapons
func get_projectile_weapon_defs(projectile_weapon: Projectile_Weapons) -> Vector3:
	match projectile_weapon:
		Projectile_Weapons.SEMI_AUTO_SECONDARY:
			return Vector3(1, 1, 1)
		Projectile_Weapons.AUTO_SECONDARY:
			return Vector3(2, 2, 2)
		Projectile_Weapons.AR:
			return Vector3(3, 3, 3)
		Projectile_Weapons.SMG:
			return Vector3(4, 4, 4)
		Projectile_Weapons.LMG:
			return Vector3(5, 5, 5)
		Projectile_Weapons.MMG:
			return Vector3(6, 6, 6)
		Projectile_Weapons.HMG:
			return Vector3(7, 7, 7)
		Projectile_Weapons.SHOTGUN:
			return Vector3(8, 8, 8)
		Projectile_Weapons.SNIPER:
			return Vector3(9, 9, 9)
		Projectile_Weapons.BAZOOKA:
			return Vector3(10, 10, 10)
		Projectile_Weapons.MINIGUN:
			return Vector3(11, 11, 11)
		Projectile_Weapons.CANNON:
			return Vector3(12, 12, 12)
		Projectile_Weapons.MORTAR:
			return Vector3(13, 13, 13)
		_:
			return Vector3(0, 0, 0)




# Function to get the name of the ammo that caused damage
# Note: Returns the ammo name, or the classname of the object, or the model name in the case of physgun ammo.
func get_projectile_type(projectile_name: String = "Unknown") -> String:

	if Bullet_Types[projectile_name] :
		# Get the ammo name from the ammo definition
		return projectile_name
	
	if _inflictor != null:
		# Get the classname of the inflictor
		projectile_name = _inflictor.get_classname()
		
		# Check for physgun ammo (assuming "prop_physics" as the class name)
		if projectile_name == "prop_physics":
			projectile_name = str(_inflictor.get_model_name())
	
	return projectile_name






func calculate_explosive_damage_force(dmg_src: Damage_Source, vec_dir: Vector3, vec_force_origin: Vector3, fl_scale: float = 1.0):
	
	# Set the damage position in the info object
	dmg_src.set_damage_position(vec_force_origin)
	
	# Constants
	var clamp_force = impulse_scale(75, 400)
	
	# Calculate an impulse large enough to push a 75kg object 4 in/sec per point of damage
	var force_scale = dmg_src.get_base_damage() * impulse_scale(75, 4)
	
	# Clamp the force if it exceeds the clamping force
	if force_scale > clamp_force:
		force_scale = clamp_force
	
	# Fudge blast forces to introduce variability
	force_scale *= randf_range(0.85, 1.15)

	# Calculate the force vector
	var vec_force = vec_dir.normalized() * force_scale * _phys_pushscale

	# Apply the final scaling factor
	vec_force *= fl_scale

	# Set the damage force in the info object
	dmg_src.set_damage_force(vec_force)
	pass

#duplicate of other one
func calculate_bullet_damage_force(dmg_src: Damage_Source, Bullet_Types, vec_bullet_dir: Vector3, vec_force_origin: Vector3, fl_scale: float = 1.0) -> Damage_Source:
	var bullet = Damage_Source.new()
	# ammo type is an enum? 

	bullet.set_damage_position(vec_force_origin)
	
	# Calculate the force vector
	var vec_force = vec_bullet_dir.normalized() * damage_force(Vector3(1,1,1))
	
	# Apply scaling factors
	vec_force *= _phys_pushscale
	vec_force *= fl_scale
	
	# Set the damage force in the info object
	bullet.set_damage_force(vec_force)
	
	# Assert that the force vector is not equal to vec3_origin
	assert(vec_force != Vector3(0, 0, 0))

	return Damage_Source.new()


	
func calculate_melee_damage_force(dmg_src: Damage_Source, vec_melee_dir: Vector3, vec_force_origin: Vector3, fl_scale: float = 1.0):
	# Set the damage position in the info object
	dmg_src.set_damage_position(vec_force_origin)	

	# Calculate an impulse large enough to push a 75kg object 4 in/sec per point of damage
	var fl_force_scale = dmg_src.get_base_damage() * impulse_scale(75, 4)	

	# Calculate the force vector
	var vec_force = vec_melee_dir.normalized() * fl_force_scale	

	# Apply scaling factors
	vec_force *= _phys_pushscale
	vec_force *= fl_scale	

	# Set the damage force in the info object
	dmg_src.set_damage_force(vec_force)

func guess_damage_force(info: Damage_Source, vec_force_dir: Vector3, vec_force_origin: Vector3, fl_scale: float = 1.0):
	# Implement the logic for GuessDamageForce here
	# You can access info, vec_force_dir, vec_force_origin, and fl_scale as parameters
	# and modify them as needed within this function
	
	var damage_type = info.get_damage_type()
	
	if damage_type.DMG_BULLET:
		calculate_bullet_damage_force(info, get_projectile_weapon_defs(Projectile_Weapons.AR), vec_force_dir, vec_force_origin, fl_scale)
	elif damage_type.DMG_BLAST:
		calculate_explosive_damage_force(info, vec_force_dir, vec_force_origin, fl_scale)
	else:
		calculate_melee_damage_force(info, vec_force_dir, vec_force_origin, fl_scale)


enum AMMO_FLAGS  {
	INFINITE_AMMO,
	AMMO_FORCE_DROP_IF_CARRIED,
	AMMO_INTERPRET_PLRDAMAGE_AS_DAMAGE_TO_PLAYER,
} 

class AmmoType:
	var name: String = ""
	var damage_type: Damage_Types = 0
	var tracer_type: TracerTypes = 0
	var min_splash_size: int = 0
	var max_splash_size: int = 0
	var flags: AMMO_FLAGS = 0
	# Values for player/NPC damage and carrying capability
	# If the integers are set, they override the CVars
	var player_damage: int = 0 # CVar for player damage amount
	var NPC_damage: int = 0 # CVar for NPC damage amount
	var max_carry: int = 0 # CVar for maximum number can carry
	var max_carry_var: String = "" # CVar for maximum number can carry
	var physics_force_impulse: float = 0.0
	var debug = false


class CAmmoDef:
	var m_AmmoType: Array = []
	var MAX_AMMO_TYPES = 13
	# Constructor
	func _init():
		for thing in range(MAX_AMMO_TYPES):
			m_AmmoType.append(AmmoType.new())

	# Add an ammo type with or without constant vars
	func add_ammo_type(
		name: String,
		damage_type: int,
		tracer_type: int,
		n_flags: int,
		min_splash_size: int,
		max_splash_size: int,
		plr_cvar: String = "",
		npc_cvar: String = "",
		carry_cvar: String = "",
		physics_force_impulse: float = 0.0
	) -> bool:
		if m_AmmoType.size() >= MAX_AMMO_TYPES:
			return false

		var ammo = AmmoType.new()
		ammo.pName = name
		ammo.nDamageType = damage_type
		ammo.eTracerType = tracer_type
		ammo.nMinSplashSize = min_splash_size
		ammo.nMaxSplashSize = max_splash_size
		ammo.nFlags = n_flags

		if plr_cvar != "":
			ammo.pPlrDmgCVar = plr_cvar
			ammo.pPlrDmg = 1

		if npc_cvar != "":
			ammo.pNPCDmgCVar = npc_cvar
			ammo.pNPCDmg = 1

		if carry_cvar != "":
			ammo.pMaxCarryCVar = carry_cvar
			ammo.pMaxCarry = 1

		ammo.physicsForceImpulse = physics_force_impulse

		m_AmmoType.append(ammo)
		return true


# gpt to convert these to different cases 

func setInflictor(inflictor: Object):
	_inflictor = inflictor
	
func getInflictor():
	return _inflictor 

func fromInflictor() -> Damage_Source:
	return Damage_Source.new()


func setWeapon(weapon: Object):
	_weapon = weapon

func getWeapon():
	return _weapon 

func setAttacker(value: Object) -> void:
	_attacker = value

func getAttacker() -> Object:
	return _attacker

func setDamage(value: float) -> void:
	_damage = value

func getDamage() -> float:
	return _damage

func setMaxDamage(value: float) -> void:
	_maxDamage = value

func getMaxDamage() -> float:
	return _maxDamage

func setDamageBonus(value: float) -> void:
	_damageBonus = value

func getDamageBonus() -> float:
	return _damageBonus

func setBaseDamage(value: float) -> void:
	_baseDamage = value

func getBaseDamage() -> float:
	return _baseDamage

func setDamageForce(value: Vector3) -> void:
	_damageForce = value

func getDamageForce() -> Vector3:
	return _damageForce

func setDamagePosition(value: Vector3) -> void:
	_damagePosition = value

func getDamagePosition() -> Vector3:
	return _damagePosition

func setReportedPosition(value: Vector3) -> void:
	_reportedPosition = value

func getReportedPosition() -> Vector3:
	return _reportedPosition

func setDamageType(value: int) -> void:
	_damageType = value

func getDamageType() -> int:
	return _damageType

func setDamageCustom(value: int) -> void:
	_damageCustom = value

func getDamageCustom() -> int:
	return _damageCustom

func setDamageStats(value: int) -> void:
	_damageStats = value

func getDamageStats():
	return _damageStats
func setAmmoType(ammoType):
	_ammoType = ammoType
func getAmmoType():
	return _ammoType
	
func setPlayerPenetrationCount(playerPenetrationCount):
	_playerPenetrationCount = playerPenetrationCount
func getPlayerPenetrationCount():
	return _playerPenetrationCount
func setDamagedOtherPlayers(damagedOtherPlayers):
	_damagedOtherPlayers = damagedOtherPlayers 
func getDamagedOtherPlayers():
	return _damagedOtherPlayers
func setForceFriendlyFire(forceFriendlyFire):
	_forceFriendlyFire = forceFriendlyFire 
func getForceFriendlyFire():
	return _forceFriendlyFire











#func add_multi_damage(info: Damage_Source, entity: Object) -> void:
#	if entity == null:
#		return
#
#	if entity != g_multi_damage.target:
#		apply_multi_damage()
#		g_multi_damage.init(
#			entity,
#			info.get_inflictor(),
#			info.get_attacker(),
#			info.get_weapon(),
#			Vector3(0, 0, 0),
#			Vector3(0, 0, 0),
#			Vector3(0, 0, 0),
#			0.0,
#			info.get_damage_type(),
#			info.get_damage_custom()
#		)
#
#	g_multi_damage.add_damage_type(info.get_damage_type())
#	g_multi_damage.set_damage(g_multi_damage.get_damage() + info.get_damage())
#	g_multi_damage.set_damage_force(g_multi_damage.get_damage_force() + info.get_damage_force())
#	g_multi_damage.set_damage_position(info.get_damage_position())
#	g_multi_damage.set_reported_position(info.get_reported_position())
#	g_multi_damage.set_max_damage(max(g_multi_damage.get_max_damage(), info.get_damage()))
#	g_multi_damage.set_ammo_type(info.get_ammo_type())
#
#	if g_multi_damage.get_player_penetration_count() == 0:
#		g_multi_damage.set_player_penetration_count(info.get_player_penetration_count())
#
#	var has_physics_force_damage = not g_game_rules.damage_no_physics_force(info.get_damage_type())
#
#	if has_physics_force_damage and g_multi_damage.get_damage_type() != DMG_GENERIC:
#		if g_multi_damage.get_damage_force() == Vector3(0, 0, 0) or g_multi_damage.get_damage_position() == Vector3(0, 0, 0):
#			var warning_count = 0
#
#			if warning_count < 10:
#				if g_multi_damage.get_damage_force() == Vector3(0, 0, 0):
#					print("AddMultiDamage: g_multi_damage.get_damage_force() == Vector3(0, 0, 0)")
#				if g_multi_damage.get_damage_position() == Vector3(0, 0, 0):
#					print("AddMultiDamage: g_multi_damage.get_damage_position() == Vector3(0, 0, 0)")
#
#				warning_count += 1
#





